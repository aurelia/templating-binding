// Generated by dts-bundle-generator v6.5.0

import { BindingExpression, EventManager, Expression, ListenerExpression, LookupFunctions, ObserverLocator, Parser, SVGAnalyzer, bindingMode } from 'aurelia-binding';
import { BehaviorInstruction, BindingLanguage, HtmlBehaviorResource, ViewResources } from 'aurelia-templating';

export declare class AttributeMap {
	elements: any;
	allElements: any;
	constructor(svg: SVGAnalyzer);
	/**
	 * Maps a specific HTML element attribute to a javascript property.
	 */
	register(elementName: string, attributeName: string, propertyName: string): void;
	/**
	 * Maps an HTML attribute to a javascript property.
	 */
	registerUniversal(attributeName: string, propertyName: string): void;
	/**
	 * Returns the javascript property name for a particlar HTML attribute.
	 */
	map(elementName: string, attributeName: string): any;
}
export declare class InterpolationBindingExpression {
	constructor(observerLocator: ObserverLocator, targetProperty: string, parts: (string | Expression)[], mode: bindingMode, lookupFunctions: LookupFunctions, attribute: string);
	createBinding(target: any): ChildInterpolationBinding | InterpolationBinding;
}
export declare class InterpolationBinding {
	constructor(observerLocator: ObserverLocator, parts: (string | Expression)[], target: any, targetProperty: string, mode: bindingMode, lookupFunctions: LookupFunctions);
	interpolate(): void;
	updateOneTimeBindings(): void;
	bind(source: any): void;
	unbind(): void;
}
export declare class ChildInterpolationBinding {
	constructor(target: InterpolationBinding, observerLocator: ObserverLocator, sourceExpression: Expression, mode: bindingMode, lookupFunctions: LookupFunctions, targetProperty?: string, left?: string, right?: string);
	updateTarget(value: any): void;
	call(): void;
	bind(source: any): void;
	unbind(): void;
	connect(evaluate: any): void;
}
/**
 * An object describing information analyzed from an attribute in an Aurelia templates
 */
export interface AttributeInfo {
	command?: string;
	expression?: string | BindingExpression;
	attrName?: string;
	attrValue?: string;
	defaultBindingMode?: bindingMode;
}
export declare class SyntaxInterpreter {
	language: BindingLanguage;
	constructor(parser: Parser, observerLocator: ObserverLocator, eventManager: EventManager, attributeMap: AttributeMap);
	interpret(resources: ViewResources, element: Element, info: AttributeInfo, existingInstruction?: BehaviorInstruction, context?: HtmlBehaviorResource): any;
	handleUnknownCommand(resources: ViewResources, element: Element, info: AttributeInfo, existingInstruction: BehaviorInstruction, context: HtmlBehaviorResource): BehaviorInstruction;
	determineDefaultBindingMode(element: Element, attrName: string, context: HtmlBehaviorResource): bindingMode;
	bind(resources: ViewResources, element: Element, info: AttributeInfo, existingInstruction: BehaviorInstruction, context: HtmlBehaviorResource): BehaviorInstruction;
	trigger(resources: ViewResources, element: any, info: AttributeInfo): ListenerExpression;
	capture(resources: ViewResources, element: any, info: AttributeInfo): ListenerExpression;
	delegate(resources: ViewResources, element: any, info: AttributeInfo): ListenerExpression;
	call(resources: ViewResources, element: any, info: AttributeInfo, existingInstruction: BehaviorInstruction): BehaviorInstruction;
	options(resources: ViewResources, element: Element, info: AttributeInfo, existingInstruction: BehaviorInstruction, context: HtmlBehaviorResource): BehaviorInstruction;
	"for"(resources: ViewResources, element: Element, info: AttributeInfo, existingInstruction: BehaviorInstruction): BehaviorInstruction & {
		attributes: Record<string, any>;
	};
	"two-way"(resources: ViewResources, element: Element, info: AttributeInfo, existingInstruction: BehaviorInstruction): BehaviorInstruction;
	"to-view"(resources: ViewResources, element: Element, info: AttributeInfo, existingInstruction: BehaviorInstruction): BehaviorInstruction;
	"from-view"(resources: ViewResources, element: Element, info: AttributeInfo, existingInstruction: BehaviorInstruction): BehaviorInstruction;
	"one-time"(resources: ViewResources, element: Element, info: AttributeInfo, existingInstruction: BehaviorInstruction): BehaviorInstruction;
}
export declare class TemplatingBindingLanguage extends BindingLanguage {
	constructor(parser: Parser, observerLocator: ObserverLocator, syntaxInterpreter: SyntaxInterpreter, attributeMap: AttributeMap);
	inspectAttribute(resources: ViewResources, elementName: string, attrName: string, attrValue: string): AttributeInfo;
	createAttributeInstruction(resources: ViewResources, element: Element, theInfo: AttributeInfo, existingInstruction: BehaviorInstruction, context: HtmlBehaviorResource): any;
	createLetExpressions(resources: ViewResources, letElement: Element): any[];
	inspectTextContent(resources: ViewResources, value: string): InterpolationBindingExpression;
	parseInterpolation(resources: ViewResources, value: string): any;
}
export declare class LetExpression {
	/**
	 * @param observerLocator
	 * @param targetProperty
	 * @param sourceExpression
	 * @param lookupFunctions
	 * @param toBindingContext indicates let binding result should be assigned to binding context
	 */
	constructor(observerLocator: ObserverLocator, targetProperty: string, sourceExpression: Expression, lookupFunctions: LookupFunctions, toBindingContext: boolean);
	createBinding(): LetBinding;
}
export declare class LetBinding {
	/**
	 * @param observerLocator
	 * @param sourceExpression
	 * @param targetProperty
	 * @param lookupFunctions
	 * @param toBindingContext indicates let binding result should be assigned to binding context
	 */
	constructor(observerLocator: ObserverLocator, sourceExpression: Expression, targetProperty: string, lookupFunctions: LookupFunctions, toBindingContext: boolean);
	updateTarget(): void;
	call(context: any): void;
	/**
	 * @param {Scope} source Binding context
	 */
	bind(source: any): void;
	unbind(): void;
	unobserve(arg0: boolean): void;
	connect(): void;
}
export declare class LetInterpolationBindingExpression {
	/**
	 * @param {ObserverLocator} observerLocator
	 * @param {string} targetProperty
	 * @param {string[]} parts
	 * @param {LookupFunctions} lookupFunctions
	 * @param {boolean} toBindingContext indicates let binding result should be assigned to binding context
	 */
	constructor(observerLocator: ObserverLocator, targetProperty: string, parts: string[], lookupFunctions: LookupFunctions, toBindingContext: boolean);
	createBinding(): LetInterpolationBinding;
}
export declare class LetInterpolationBinding {
	/**
	 * @param observerLocator
	 * @param targetProperty
	 * @param parts
	 * @param lookupFunctions
	 * @param toBindingContext indicates let binding result should be assigned to binding context
	 */
	constructor(observerLocator: ObserverLocator, targetProperty: string, parts: (string | Expression)[], lookupFunctions: LookupFunctions, toBindingContext: boolean);
	/**
	 * @param {Scope} source
	 */
	bind(source: any): void;
	unbind(): void;
	createInterpolationBinding(): ChildInterpolationBinding | InterpolationBinding;
}
export declare function configure(config: any): void;

export {};
